# Data Structures & Algorithms (DSA) Study Guide

DSA is the most critical topic for any software engineering role, including ML Engineer. A strong foundation here is essential for writing efficient, scalable, and optimized code.

---

### 1. Why is DSA so Important?

- **Problem Solving:** It provides a framework for breaking down complex problems into smaller, manageable parts.
- **Efficiency:** Understanding DSA allows you to choose the right tools for the job, resulting in code that is faster (time complexity) and uses less memory (space complexity).
- **Interview Standard:** It's the global standard for technical interviews at top tech companies.

---

### 2. Core Topics

#### A. Complexity Analysis
- **Big O Notation:** Understand what `O(1)`, `O(log n)`, `O(n)`, `O(n log n)`, `O(n^2)`, and `O(2^n)` mean. Be able to derive the time and space complexity of any algorithm you write or see.

#### B. Core Data Structures
You should be able to implement these from scratch.

- **Arrays & Strings:** Master manipulation, traversal, and common algorithms.
- **Linked Lists:** Singly, Doubly, and Circular. Understand traversal, insertion, deletion, and reversal.
- **Stacks & Queues:** Understand LIFO/FIFO principles. Implement them using arrays or linked lists. Know their applications (e.g., recursion, BFS).
- **Hash Tables (Hash Maps):** The most frequently used data structure. Understand how they work, including hash functions and collision handling (chaining, open addressing).
- **Trees:**
  - **Binary Trees:** Traversal methods (In-order, Pre-order, Post-order).
  - **Binary Search Trees (BST):** Searching, insertion, and deletion.
  - **Heaps:** Min-Heap and Max-Heap. Understand `heapify`, `insert`, and `extract_max/min`. Often used for priority queues.
- **Graphs:**
  - **Representations:** Adjacency Matrix vs. Adjacency List. Know the trade-offs.
  - **Traversals:** Breadth-First Search (BFS) and Depth-First Search (DFS).

#### C. Key Algorithms
- **Searching:** Binary Search (on sorted arrays).
- **Sorting:**
  - **Merge Sort** and **Quick Sort:** Understand their implementation, complexity (average vs. worst-case), and trade-offs.
  - **Heap Sort:** In-place sorting algorithm using a heap.
- **Graph Algorithms:**
  - **Shortest Path:** Dijkstra's Algorithm.
  - **Topological Sort:** For Directed Acyclic Graphs (DAGs).
- **Dynamic Programming (DP):**
  - Understand the concepts of memoization and tabulation.
  - Practice classic problems like Fibonacci sequence, 0/1 Knapsack, and Longest Common Subsequence.

---

### 3. How to Prepare

1.  **Learn the Concept:** Use a video or article to understand the theory behind a data structure or algorithm.
2.  **Implement from Scratch:** Open your code editor and implement it in your preferred language (Python is great for ML roles) without looking at the solution.
3.  **Solve Problems:** Solve 5-10 related problems on a platform like LeetCode. Start with "Easy" and move to "Medium."
4.  **Repeat:** Do this for every topic listed above.

---

### 4. Recommended Resources

- **Problem Solving & Contests:**
  - **LeetCode:** The gold standard for interview preparation.
  - **GeeksforGeeks:** Great for topic-wise articles and a wide variety of problems.
  - **HackerRank:** Good for structured learning paths.
- **Books:**
  - **"Cracking the Coding Interview" by Gayle Laakmann McDowell:** A must-read for interview strategies and common problems.
- **YouTube Channels:**
  - **NeetCode:** Provides excellent video explanations for LeetCode problems.
  - **Abdul Bari:** Famous for clear, detailed explanations of complex algorithms.
